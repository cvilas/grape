# =================================================================================================
# Copyright (C) 2025 GRAPE Contributors
# =================================================================================================

#=================================================================================================
# Set up facilities for python nanobind
find_package(Python REQUIRED COMPONENTS Interpreter Development.Module)
FetchContent_Declare(
  nanobind
  URL ${CMAKE_SOURCE_DIR}/external/sources/nanobind-${NANOBIND_VERSION_REQUIRED}.tar.gz
  EXCLUDE_FROM_ALL
  SYSTEM)
set(NB_TEST OFF CACHE INTERNAL "")
FetchContent_MakeAvailable(nanobind)

# Where all the Python wheels go
set(PY_WHEELS_DIR ${CMAKE_BINARY_DIR}/share/${CMAKE_PROJECT_NAME}/py/wheels)

# Install rule for wheels 
install(DIRECTORY ${PY_WHEELS_DIR}/ DESTINATION ${CMAKE_INSTALL_DATAROOTDIR}/${CMAKE_PROJECT_NAME}/py/wheels)

# Delete wheels on 'clean' target
set_property(DIRECTORY APPEND PROPERTY ADDITIONAL_CLEAN_FILES ${PY_WHEELS_DIR})

#==================================================================================================
# Function: define_module_pybinding
#
# Description:
# Creates a Python binding from the given sources, and packages it into a redistributable 'wheel'
#
# Parameters:
#   NAME: The name of the Python module.
#   SOURCES: A list of source files for the module.
#
# Usage: 
# See ipc module for an example of usage
#
function(define_module_pybinding)
  set(options "")
  set(oneValueArgs NAME)
  set(multiValueArgs SOURCES)
  cmake_parse_arguments(ARG "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

  if(NOT ARG_NAME)
    message(FATAL_ERROR "define_module_pybinding: NAME not specified")
  endif()

  if(NOT ARG_SOURCES)
    message(FATAL_ERROR "define_module_pybinding: SOURCES not specified")
  endif()

  # set python extension module name. Required by autogenerated module files 
  # Note: This is passed to NB_MODULE() macro as Python module name (which is what is use
  # to import the module in a Python script)
  set(PY_MODULE_NAME ${ARG_NAME})

  # Build python extension module and link to libraries from the enclosing module
  nanobind_add_module(${PY_MODULE_NAME} ${ARG_SOURCES})
  target_link_libraries(${PY_MODULE_NAME} PRIVATE ${MODULE_${MODULE_NAME}_LIB_TARGETS}) 
  add_clang_format(${PY_MODULE_NAME})

  # Treat nanobind as a third-party library
  # - disable clang-tidy
  # - relax compiler warnings
  # - mark include directories as SYSTEM to suppress warnings in nanobind headers
  set_target_properties(nanobind-static PROPERTIES CXX_CLANG_TIDY "")
  set_target_properties(nanobind-static PROPERTIES COMPILE_OPTIONS ${THIRD_PARTY_COMPILER_WARNINGS})
  get_target_property(nanobind_include_directories nanobind-static INTERFACE_INCLUDE_DIRECTORIES)
  set_target_properties(nanobind-static PROPERTIES INTERFACE_INCLUDE_DIRECTORIES "")
  target_include_directories(nanobind-static SYSTEM INTERFACE ${nanobind_include_directories})

  # generate module directory structure
  set(PY_BINDINGS_DIR ${CMAKE_CURRENT_BINARY_DIR}/${PY_MODULE_NAME})
  file(MAKE_DIRECTORY ${PY_BINDINGS_DIR})
  configure_file(${GBS_TEMPLATES_DIR}/py/__init__.py.in ${PY_BINDINGS_DIR}/__init__.py @ONLY)
  configure_file(${GBS_TEMPLATES_DIR}/py/setup.py.in ${CMAKE_CURRENT_BINARY_DIR}/setup.py @ONLY)

  # Package module as wheel
  add_custom_command(
    TARGET ${PY_MODULE_NAME} POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy $<TARGET_FILE:${PY_MODULE_NAME}> ${PY_BINDINGS_DIR}/
    COMMAND ${Python_EXECUTABLE} -m build --wheel --no-isolation --outdir ${PY_WHEELS_DIR} > 
    ${CMAKE_CURRENT_BINARY_DIR}/wheel_build.log 2>&1 || (cat ${CMAKE_CURRENT_BINARY_DIR}/wheel_build.log && exit 1)
    WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
    COMMENT "Building Python package (wheel) for ${PY_MODULE_NAME}")
    
endfunction()
